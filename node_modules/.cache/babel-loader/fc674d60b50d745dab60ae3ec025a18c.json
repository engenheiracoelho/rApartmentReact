{"ast":null,"code":"import { spy, configure, getDependencyTree, Reaction, observable, runInAction, transaction } from 'mobx';\nimport React, { useState, useCallback, memo, forwardRef } from 'react';\n\nif (!useState) {\n  throw new Error(\"mobx-react-lite requires React with Hooks support\");\n}\n\nif (!spy) {\n  throw new Error(\"mobx-react-lite requires mobx at least version 4 to be available\");\n}\n\nvar globalIsUsingStaticRendering = false;\n\nfunction useStaticRendering(enable) {\n  globalIsUsingStaticRendering = enable;\n}\n\nfunction isUsingStaticRendering() {\n  return globalIsUsingStaticRendering;\n}\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction useForceUpdate() {\n  var _useState = useState(0),\n      setTick = _useState[1];\n\n  var update = useCallback(function () {\n    setTick(function (tick) {\n      return tick + 1;\n    });\n  }, []);\n  return update;\n}\n\nfunction isPlainObject(value) {\n  if (!value || typeof value !== \"object\") {\n    return false;\n  }\n\n  var proto = Object.getPrototypeOf(value);\n  return !proto || proto === Object.prototype;\n}\n\nfunction getSymbol(name) {\n  if (typeof Symbol === \"function\") {\n    return Symbol.for(name);\n  }\n\n  return \"__$mobx-react \" + name + \"__\";\n}\n\nvar mockGlobal = {};\n\nfunction getGlobal() {\n  if (typeof window !== \"undefined\") {\n    return window;\n  }\n\n  if (typeof global !== \"undefined\") {\n    return global;\n  }\n\n  if (typeof self !== \"undefined\") {\n    return self;\n  }\n\n  return mockGlobal;\n}\n\nvar observerBatchingConfiguredSymbol = /*#__PURE__*/getSymbol(\"observerBatching\");\n\nvar observerBatching = function observerBatching(reactionScheduler) {\n  if (typeof reactionScheduler === \"function\") {\n    configure({\n      reactionScheduler: reactionScheduler\n    });\n  }\n\n  getGlobal()[observerBatchingConfiguredSymbol] = true;\n};\n\nvar observerBatchingOptOut = function observerBatchingOptOut() {\n  configure({\n    reactionScheduler: undefined\n  });\n  getGlobal()[observerBatchingConfiguredSymbol] = true;\n};\n\nvar isObserverBatched = function isObserverBatched() {\n  return getGlobal()[observerBatchingConfiguredSymbol];\n};\n\nfunction printDebugValue(v) {\n  return getDependencyTree(v);\n}\n\nfunction createTrackingData(reaction) {\n  var trackingData = {\n    cleanAt: Date.now() + CLEANUP_LEAKED_REACTIONS_AFTER_MILLIS,\n    reaction: reaction\n  };\n  return trackingData;\n}\n/**\r\n * The minimum time before we'll clean up a Reaction created in a render\r\n * for a component that hasn't managed to run its effects. This needs to\r\n * be big enough to ensure that a component won't turn up and have its\r\n * effects run without being re-rendered.\r\n */\n\n\nvar CLEANUP_LEAKED_REACTIONS_AFTER_MILLIS = 10000;\n/**\r\n * The frequency with which we'll check for leaked reactions.\r\n */\n\nvar CLEANUP_TIMER_LOOP_MILLIS = 10000;\n/**\r\n * Reactions created by components that have yet to be fully mounted.\r\n */\n\nvar uncommittedReactionRefs = /*#__PURE__*/new Set();\n/**\r\n * Latest 'uncommitted reactions' cleanup timer handle.\r\n */\n\nvar reactionCleanupHandle;\n\nfunction ensureCleanupTimerRunning() {\n  if (reactionCleanupHandle === undefined) {\n    reactionCleanupHandle = setTimeout(cleanUncommittedReactions, CLEANUP_TIMER_LOOP_MILLIS);\n  }\n}\n\nfunction scheduleCleanupOfReactionIfLeaked(ref) {\n  uncommittedReactionRefs.add(ref);\n  ensureCleanupTimerRunning();\n}\n\nfunction recordReactionAsCommitted(reactionRef) {\n  uncommittedReactionRefs.delete(reactionRef);\n}\n/**\r\n * Run by the cleanup timer to dispose any outstanding reactions\r\n */\n\n\nfunction cleanUncommittedReactions() {\n  reactionCleanupHandle = undefined; // Loop through all the candidate leaked reactions; those older\n  // than CLEANUP_LEAKED_REACTIONS_AFTER_MILLIS get tidied.\n\n  var now = Date.now();\n\n  for (var _iterator = uncommittedReactionRefs, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n    var _ref;\n\n    if (_isArray) {\n      if (_i >= _iterator.length) break;\n      _ref = _iterator[_i++];\n    } else {\n      _i = _iterator.next();\n      if (_i.done) break;\n      _ref = _i.value;\n    }\n\n    var ref = _ref;\n    var tracking = ref.current;\n\n    if (tracking) {\n      if (now >= tracking.cleanAt) {\n        // It's time to tidy up this leaked reaction.\n        tracking.reaction.dispose();\n        ref.current = null;\n        uncommittedReactionRefs.delete(ref);\n      }\n    }\n  }\n\n  if (uncommittedReactionRefs.size > 0) {\n    // We've just finished a round of cleanups but there are still\n    // some leak candidates outstanding.\n    ensureCleanupTimerRunning();\n  }\n}\n\nvar EMPTY_OBJECT = {};\n\nfunction observerComponentNameFor(baseComponentName) {\n  return \"observer\" + baseComponentName;\n}\n\nvar warnedAboutBatching = false;\n\nfunction useObserver(fn, baseComponentName, options) {\n  if (baseComponentName === void 0) {\n    baseComponentName = \"observed\";\n  }\n\n  if (options === void 0) {\n    options = EMPTY_OBJECT;\n  }\n\n  if (isUsingStaticRendering()) {\n    return fn();\n  }\n\n  if (process.env.NODE_ENV !== \"production\" && !warnedAboutBatching && !isObserverBatched()) {\n    console.warn(\"[MobX] You haven't configured observer batching which might result in unexpected behavior in some cases. See more at https://github.com/mobxjs/mobx-react-lite/#observer-batching\");\n    warnedAboutBatching = true;\n  }\n\n  var wantedForceUpdateHook = options.useForceUpdate || useForceUpdate;\n  var forceUpdate = wantedForceUpdateHook(); // StrictMode/ConcurrentMode/Suspense may mean that our component is\n  // rendered and abandoned multiple times, so we need to track leaked\n  // Reactions.\n\n  var reactionTrackingRef = React.useRef(null);\n\n  if (!reactionTrackingRef.current) {\n    // First render for this component (or first time since a previous\n    // reaction from an abandoned render was disposed).\n    var newReaction = new Reaction(observerComponentNameFor(baseComponentName), function () {\n      // Observable has changed, meaning we want to re-render\n      // BUT if we're a component that hasn't yet got to the useEffect()\n      // stage, we might be a component that _started_ to render, but\n      // got dropped, and we don't want to make state changes then.\n      // (It triggers warnings in StrictMode, for a start.)\n      if (trackingData.mounted) {\n        // We have reached useEffect(), so we're mounted, and can trigger an update\n        forceUpdate();\n      } else {\n        // We haven't yet reached useEffect(), so we'll need to trigger a re-render\n        // when (and if) useEffect() arrives.  The easiest way to do that is just to\n        // drop our current reaction and allow useEffect() to recreate it.\n        newReaction.dispose();\n        reactionTrackingRef.current = null;\n      }\n    });\n    var trackingData = createTrackingData(newReaction);\n    reactionTrackingRef.current = trackingData;\n    scheduleCleanupOfReactionIfLeaked(reactionTrackingRef);\n  }\n\n  var reaction = reactionTrackingRef.current.reaction;\n  React.useDebugValue(reaction, printDebugValue);\n  React.useEffect(function () {\n    // Called on first mount only\n    recordReactionAsCommitted(reactionTrackingRef);\n\n    if (reactionTrackingRef.current) {\n      // Great. We've already got our reaction from our render;\n      // all we need to do is to record that it's now mounted,\n      // to allow future observable changes to trigger re-renders\n      reactionTrackingRef.current.mounted = true;\n    } else {\n      // The reaction we set up in our render has been disposed.\n      // This is either due to bad timings of renderings, e.g. our\n      // component was paused for a _very_ long time, and our\n      // reaction got cleaned up, or we got a observable change\n      // between render and useEffect\n      // Re-create the reaction\n      reactionTrackingRef.current = {\n        reaction: new Reaction(observerComponentNameFor(baseComponentName), function () {\n          // We've definitely already been mounted at this point\n          forceUpdate();\n        }),\n        cleanAt: Infinity\n      };\n      forceUpdate();\n    }\n\n    return function () {\n      reactionTrackingRef.current.reaction.dispose();\n      reactionTrackingRef.current = null;\n    };\n  }, []); // render the original component, but have the\n  // reaction track the observables, so that rendering\n  // can be invalidated (see above) once a dependency changes\n\n  var rendering;\n  var exception;\n  reaction.track(function () {\n    try {\n      rendering = fn();\n    } catch (e) {\n      exception = e;\n    }\n  });\n\n  if (exception) {\n    throw exception; // re-throw any exceptions catched during rendering\n  }\n\n  return rendering;\n}\n\nfunction observer(baseComponent, options) {\n  // The working of observer is explained step by step in this talk: https://www.youtube.com/watch?v=cPF4iBedoF0&feature=youtu.be&t=1307\n  if (isUsingStaticRendering()) {\n    return baseComponent;\n  }\n\n  var realOptions = _extends({\n    forwardRef: false\n  }, options);\n\n  var baseComponentName = baseComponent.displayName || baseComponent.name;\n\n  var wrappedComponent = function wrappedComponent(props, ref) {\n    return useObserver(function () {\n      return baseComponent(props, ref);\n    }, baseComponentName);\n  };\n\n  wrappedComponent.displayName = baseComponentName; // memo; we are not intested in deep updates\n  // in props; we assume that if deep objects are changed,\n  // this is in observables, which would have been tracked anyway\n\n  var memoComponent;\n\n  if (realOptions.forwardRef) {\n    // we have to use forwardRef here because:\n    // 1. it cannot go before memo, only after it\n    // 2. forwardRef converts the function into an actual component, so we can't let the baseComponent do it\n    //    since it wouldn't be a callable function anymore\n    memoComponent = memo(forwardRef(wrappedComponent));\n  } else {\n    memoComponent = memo(wrappedComponent);\n  }\n\n  copyStaticProperties(baseComponent, memoComponent);\n  memoComponent.displayName = baseComponentName;\n  return memoComponent;\n} // based on https://github.com/mridgway/hoist-non-react-statics/blob/master/src/index.js\n\n\nvar hoistBlackList = {\n  $$typeof: true,\n  render: true,\n  compare: true,\n  type: true\n};\n\nfunction copyStaticProperties(base, target) {\n  Object.keys(base).forEach(function (key) {\n    if (!hoistBlackList[key]) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(base, key));\n    }\n  });\n}\n\nfunction ObserverComponent(_ref) {\n  var children = _ref.children,\n      render = _ref.render;\n  var component = children || render;\n\n  if (typeof component !== \"function\") {\n    return null;\n  }\n\n  return useObserver(component);\n}\n\nObserverComponent.propTypes = {\n  children: ObserverPropsCheck,\n  render: ObserverPropsCheck\n};\nObserverComponent.displayName = \"Observer\";\n\nfunction ObserverPropsCheck(props, key, componentName, location, propFullName) {\n  var extraKey = key === \"children\" ? \"render\" : \"children\";\n  var hasProp = typeof props[key] === \"function\";\n  var hasExtraProp = typeof props[extraKey] === \"function\";\n\n  if (hasProp && hasExtraProp) {\n    return new Error(\"MobX Observer: Do not use children and render in the same time in`\" + componentName);\n  }\n\n  if (hasProp || hasExtraProp) {\n    return null;\n  }\n\n  return new Error(\"Invalid prop `\" + propFullName + \"` of type `\" + typeof props[key] + \"` supplied to\" + \" `\" + componentName + \"`, expected `function`.\");\n}\n\nfunction useAsObservableSourceInternal(current, usedByLocalStore) {\n  var culprit = usedByLocalStore ? \"useLocalStore\" : \"useAsObservableSource\";\n\n  if (usedByLocalStore && current === undefined) {\n    return undefined;\n  }\n\n  if (process.env.NODE_ENV !== \"production\" && !isPlainObject(current)) {\n    throw new Error(culprit + \" expects a plain object as \" + (usedByLocalStore ? \"second\" : \"first\") + \" argument\");\n  }\n\n  var _React$useState = React.useState(function () {\n    return observable(current, {}, {\n      deep: false\n    });\n  }),\n      res = _React$useState[0];\n\n  if (process.env.NODE_ENV !== \"production\" && Object.keys(res).length !== Object.keys(current).length) {\n    throw new Error(\"the shape of objects passed to \" + culprit + \" should be stable\");\n  }\n\n  runInAction(function () {\n    Object.assign(res, current);\n  });\n  return res;\n}\n\nfunction useAsObservableSource(current) {\n  return useAsObservableSourceInternal(current, false);\n}\n\nfunction useLocalStore(initializer, current) {\n  var source = useAsObservableSourceInternal(current, true);\n  return React.useState(function () {\n    var local = observable(initializer(source));\n\n    if (isPlainObject(local)) {\n      runInAction(function () {\n        Object.keys(local).forEach(function (key) {\n          var value = local[key];\n\n          if (typeof value === \"function\") {\n            // @ts-ignore No idea why ts2536 is popping out here\n            local[key] = wrapInTransaction(value, local);\n          }\n        });\n      });\n    }\n\n    return local;\n  })[0];\n} // tslint:disable-next-line: ban-types\n\n\nfunction wrapInTransaction(fn, context) {\n  return function () {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return transaction(function () {\n      return fn.apply(context, args);\n    });\n  };\n}\n\nexport { ObserverComponent as Observer, isObserverBatched, isUsingStaticRendering, observer, observerBatching, observerBatchingOptOut, useAsObservableSource, useForceUpdate, useLocalStore, useObserver, useStaticRendering };","map":{"version":3,"sources":["../src/assertEnvironment.ts","../src/staticRendering.ts","../src/utils.ts","../src/observerBatching.ts","../src/printDebugValue.ts","../src/reactionCleanupTracking.ts","../src/useObserver.ts","../src/observer.ts","../src/ObserverComponent.ts","../src/useAsObservableSource.ts","../src/useLocalStore.ts"],"names":["globalIsUsingStaticRendering","useStaticRendering","enable","isUsingStaticRendering","useForceUpdate","setTick","useState","update","useCallback","tick","isPlainObject","value","proto","Object","getSymbol","name","Symbol","mockGlobal","getGlobal","observerBatchingConfiguredSymbol","observerBatching","configure","reactionScheduler","observerBatchingOptOut","undefined","isObserverBatched","printDebugValue","v","getDependencyTree","createTrackingData","reaction","trackingData","cleanAt","Date","CLEANUP_LEAKED_REACTIONS_AFTER_MILLIS","CLEANUP_TIMER_LOOP_MILLIS","uncommittedReactionRefs","reactionCleanupHandle","setTimeout","scheduleCleanupOfReactionIfLeaked","ref","ensureCleanupTimerRunning","recordReactionAsCommitted","reactionRef","now","tracking","EMPTY_OBJECT","warnedAboutBatching","useObserver","fn","baseComponentName","options","console","wantedForceUpdateHook","forceUpdate","reactionTrackingRef","React","newReaction","observerComponentNameFor","current","Infinity","rendering","exception","observer","baseComponent","realOptions","forwardRef","wrappedComponent","memoComponent","memo","copyStaticProperties","hoistBlackList","$$typeof","render","compare","type","children","component","ObserverComponent","ObserverPropsCheck","extraKey","key","hasProp","props","hasExtraProp","useAsObservableSourceInternal","usedByLocalStore","culprit","process","res","observable","deep","runInAction","useAsObservableSource","useLocalStore","initializer","source","local","wrapInTransaction","args","transaction"],"mappings":"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","sourcesContent":["import { spy } from \"mobx\"\nimport { useState } from \"react\"\n\nif (!useState) {\n    throw new Error(\"mobx-react-lite requires React with Hooks support\")\n}\nif (!spy) {\n    throw new Error(\"mobx-react-lite requires mobx at least version 4 to be available\")\n}\n","let globalIsUsingStaticRendering = false\n\nexport function useStaticRendering(enable: boolean) {\n    globalIsUsingStaticRendering = enable\n}\n\nexport function isUsingStaticRendering(): boolean {\n    return globalIsUsingStaticRendering\n}\n","import { useCallback, useEffect, useState } from \"react\"\n\nconst EMPTY_ARRAY: any[] = []\n\nexport function useUnmount(fn: () => void) {\n    useEffect(() => fn, EMPTY_ARRAY)\n}\n\nexport function useForceUpdate() {\n    const [, setTick] = useState(0)\n\n    const update = useCallback(() => {\n        setTick(tick => tick + 1)\n    }, [])\n\n    return update\n}\n\nexport function isPlainObject(value: any): value is object {\n    if (!value || typeof value !== \"object\") {\n        return false\n    }\n    const proto = Object.getPrototypeOf(value)\n    return !proto || proto === Object.prototype\n}\n\nexport function getSymbol(name: string): symbol | string {\n    if (typeof Symbol === \"function\") {\n        return Symbol.for(name)\n    }\n    return `__$mobx-react ${name}__`\n}\n\ndeclare const window: any\ndeclare const self: any\n\nconst mockGlobal = {}\n\nexport function getGlobal() {\n    if (typeof window !== \"undefined\") {\n        return window\n    }\n    if (typeof global !== \"undefined\") {\n        return global\n    }\n    if (typeof self !== \"undefined\") {\n        return self\n    }\n    return mockGlobal\n}\n","import { configure } from \"mobx\"\n\nimport { getGlobal, getSymbol } from \"./utils\"\n\ninterface IBatchedUpdates {\n    batchedUpdates<A, B>(callback: (a: A, b: B) => any, a: A, b: B): void\n    batchedUpdates<A>(callback: (a: A) => any, a: A): void\n    batchedUpdates(callback: () => any): void\n}\n\nconst observerBatchingConfiguredSymbol = getSymbol(\"observerBatching\")\n\nexport const observerBatching = (reactionScheduler?: IBatchedUpdates) => {\n    if (typeof reactionScheduler === \"function\") {\n        configure({ reactionScheduler })\n    }\n    getGlobal()[observerBatchingConfiguredSymbol] = true\n}\n\nexport const observerBatchingOptOut = () => {\n    configure({ reactionScheduler: undefined })\n    getGlobal()[observerBatchingConfiguredSymbol] = true\n}\n\nexport const isObserverBatched = () => getGlobal()[observerBatchingConfiguredSymbol]\n","import { getDependencyTree, Reaction } from \"mobx\"\n\nexport function printDebugValue(v: Reaction) {\n    return getDependencyTree(v)\n}\n","import { Reaction } from \"mobx\"\n\nexport interface IReactionTracking {\n    /** The Reaction created during first render, which may be leaked */\n    reaction: Reaction\n    /**\n     * The time (in ticks) at which point we should dispose of the reaction\n     * if this component hasn't yet been fully mounted.\n     */\n    cleanAt: number\n\n    /**\n     * Whether the component has yet completed mounting (for us, whether\n     * its useEffect has run)\n     */\n    mounted?: boolean\n\n    /**\n     * Whether the observables that the component is tracking changed between\n     * the first render and the first useEffect.\n     */\n    changedBeforeMount?: boolean\n}\n\nexport function createTrackingData(reaction: Reaction) {\n    const trackingData: IReactionTracking = {\n        cleanAt: Date.now() + CLEANUP_LEAKED_REACTIONS_AFTER_MILLIS,\n        reaction\n    }\n    return trackingData\n}\n\n/**\n * The minimum time before we'll clean up a Reaction created in a render\n * for a component that hasn't managed to run its effects. This needs to\n * be big enough to ensure that a component won't turn up and have its\n * effects run without being re-rendered.\n */\nexport const CLEANUP_LEAKED_REACTIONS_AFTER_MILLIS = 10_000\n\n/**\n * The frequency with which we'll check for leaked reactions.\n */\nexport const CLEANUP_TIMER_LOOP_MILLIS = 10_000\n\n/**\n * Reactions created by components that have yet to be fully mounted.\n */\nconst uncommittedReactionRefs: Set<React.MutableRefObject<IReactionTracking | null>> = new Set()\n\n/**\n * Latest 'uncommitted reactions' cleanup timer handle.\n */\nlet reactionCleanupHandle: ReturnType<typeof setTimeout> | undefined\n\nfunction ensureCleanupTimerRunning() {\n    if (reactionCleanupHandle === undefined) {\n        reactionCleanupHandle = setTimeout(cleanUncommittedReactions, CLEANUP_TIMER_LOOP_MILLIS)\n    }\n}\n\nexport function scheduleCleanupOfReactionIfLeaked(\n    ref: React.MutableRefObject<IReactionTracking | null>\n) {\n    uncommittedReactionRefs.add(ref)\n\n    ensureCleanupTimerRunning()\n}\n\nexport function recordReactionAsCommitted(\n    reactionRef: React.MutableRefObject<IReactionTracking | null>\n) {\n    uncommittedReactionRefs.delete(reactionRef)\n}\n\n/**\n * Run by the cleanup timer to dispose any outstanding reactions\n */\nfunction cleanUncommittedReactions() {\n    reactionCleanupHandle = undefined\n\n    // Loop through all the candidate leaked reactions; those older\n    // than CLEANUP_LEAKED_REACTIONS_AFTER_MILLIS get tidied.\n\n    const now = Date.now()\n    for (const ref of uncommittedReactionRefs) {\n        const tracking = ref.current\n        if (tracking) {\n            if (now >= tracking.cleanAt) {\n                // It's time to tidy up this leaked reaction.\n                tracking.reaction.dispose()\n                ref.current = null\n                uncommittedReactionRefs.delete(ref)\n            }\n        }\n    }\n\n    if (uncommittedReactionRefs.size > 0) {\n        // We've just finished a round of cleanups but there are still\n        // some leak candidates outstanding.\n        ensureCleanupTimerRunning()\n    }\n}\n\n/* istanbul ignore next */\n/**\n * Only to be used by test functions; do not export outside of mobx-react-lite\n */\nexport function forceCleanupTimerToRunNowForTests() {\n    // This allows us to control the execution of the cleanup timer\n    // to force it to run at awkward times in unit tests.\n    if (reactionCleanupHandle) {\n        clearTimeout(reactionCleanupHandle)\n        cleanUncommittedReactions()\n    }\n}\n\n/* istanbul ignore next */\nexport function resetCleanupScheduleForTests() {\n    if (reactionCleanupHandle) {\n        clearTimeout(reactionCleanupHandle)\n        reactionCleanupHandle = undefined\n    }\n    uncommittedReactionRefs.clear()\n}\n","import { Reaction } from \"mobx\"\nimport React from \"react\"\n\nimport { isObserverBatched } from \"./observerBatching\"\nimport { printDebugValue } from \"./printDebugValue\"\nimport {\n    createTrackingData,\n    IReactionTracking,\n    recordReactionAsCommitted,\n    scheduleCleanupOfReactionIfLeaked\n} from \"./reactionCleanupTracking\"\nimport { isUsingStaticRendering } from \"./staticRendering\"\nimport { useForceUpdate } from \"./utils\"\n\nexport type ForceUpdateHook = () => () => void\n\nexport interface IUseObserverOptions {\n    useForceUpdate?: ForceUpdateHook\n}\n\nconst EMPTY_OBJECT = {}\n\nfunction observerComponentNameFor(baseComponentName: string) {\n    return `observer${baseComponentName}`\n}\n\nlet warnedAboutBatching = false\n\nexport function useObserver<T>(\n    fn: () => T,\n    baseComponentName: string = \"observed\",\n    options: IUseObserverOptions = EMPTY_OBJECT\n): T {\n    if (isUsingStaticRendering()) {\n        return fn()\n    }\n\n    if (__DEV__ && !warnedAboutBatching && !isObserverBatched()) {\n        console.warn(\n            `[MobX] You haven't configured observer batching which might result in unexpected behavior in some cases. See more at https://github.com/mobxjs/mobx-react-lite/#observer-batching`\n        )\n        warnedAboutBatching = true\n    }\n\n    const wantedForceUpdateHook = options.useForceUpdate || useForceUpdate\n    const forceUpdate = wantedForceUpdateHook()\n\n    // StrictMode/ConcurrentMode/Suspense may mean that our component is\n    // rendered and abandoned multiple times, so we need to track leaked\n    // Reactions.\n    const reactionTrackingRef = React.useRef<IReactionTracking | null>(null)\n\n    if (!reactionTrackingRef.current) {\n        // First render for this component (or first time since a previous\n        // reaction from an abandoned render was disposed).\n\n        const newReaction = new Reaction(observerComponentNameFor(baseComponentName), () => {\n            // Observable has changed, meaning we want to re-render\n            // BUT if we're a component that hasn't yet got to the useEffect()\n            // stage, we might be a component that _started_ to render, but\n            // got dropped, and we don't want to make state changes then.\n            // (It triggers warnings in StrictMode, for a start.)\n            if (trackingData.mounted) {\n                // We have reached useEffect(), so we're mounted, and can trigger an update\n                forceUpdate()\n            } else {\n                // We haven't yet reached useEffect(), so we'll need to trigger a re-render\n                // when (and if) useEffect() arrives.  The easiest way to do that is just to\n                // drop our current reaction and allow useEffect() to recreate it.\n                newReaction.dispose()\n                reactionTrackingRef.current = null\n            }\n        })\n\n        const trackingData = createTrackingData(newReaction)\n        reactionTrackingRef.current = trackingData\n        scheduleCleanupOfReactionIfLeaked(reactionTrackingRef)\n    }\n\n    const { reaction } = reactionTrackingRef.current!\n    React.useDebugValue(reaction, printDebugValue)\n\n    React.useEffect(() => {\n        // Called on first mount only\n        recordReactionAsCommitted(reactionTrackingRef)\n\n        if (reactionTrackingRef.current) {\n            // Great. We've already got our reaction from our render;\n            // all we need to do is to record that it's now mounted,\n            // to allow future observable changes to trigger re-renders\n            reactionTrackingRef.current.mounted = true\n        } else {\n            // The reaction we set up in our render has been disposed.\n            // This is either due to bad timings of renderings, e.g. our\n            // component was paused for a _very_ long time, and our\n            // reaction got cleaned up, or we got a observable change\n            // between render and useEffect\n\n            // Re-create the reaction\n            reactionTrackingRef.current = {\n                reaction: new Reaction(observerComponentNameFor(baseComponentName), () => {\n                    // We've definitely already been mounted at this point\n                    forceUpdate()\n                }),\n                cleanAt: Infinity\n            }\n            forceUpdate()\n        }\n\n        return () => {\n            reactionTrackingRef.current!.reaction.dispose()\n            reactionTrackingRef.current = null\n        }\n    }, [])\n\n    // render the original component, but have the\n    // reaction track the observables, so that rendering\n    // can be invalidated (see above) once a dependency changes\n    let rendering!: T\n    let exception\n    reaction.track(() => {\n        try {\n            rendering = fn()\n        } catch (e) {\n            exception = e\n        }\n    })\n    if (exception) {\n        throw exception // re-throw any exceptions catched during rendering\n    }\n    return rendering\n}\n","import { forwardRef, memo } from \"react\"\n\nimport { isUsingStaticRendering } from \"./staticRendering\"\nimport { useObserver } from \"./useObserver\"\n\nexport interface IObserverOptions {\n    readonly forwardRef?: boolean\n}\n\nexport function observer<P extends object, TRef = {}>(\n    baseComponent: React.RefForwardingComponent<TRef, P>,\n    options: IObserverOptions & { forwardRef: true }\n): React.MemoExoticComponent<\n    React.ForwardRefExoticComponent<React.PropsWithoutRef<P> & React.RefAttributes<TRef>>\n>\n\nexport function observer<P extends object>(\n    baseComponent: React.FunctionComponent<P>,\n    options?: IObserverOptions\n): React.FunctionComponent<P>\n\nexport function observer<\n    C extends React.FunctionComponent<any> | React.RefForwardingComponent<any>,\n    Options extends IObserverOptions\n>(\n    baseComponent: C,\n    options?: Options\n): Options extends { forwardRef: true }\n    ? C extends React.RefForwardingComponent<infer TRef, infer P>\n        ? C &\n              React.MemoExoticComponent<\n                  React.ForwardRefExoticComponent<\n                      React.PropsWithoutRef<P> & React.RefAttributes<TRef>\n                  >\n              >\n        : never /* forwardRef set for a non forwarding component */\n    : C & { displayName: string }\n\n// n.b. base case is not used for actual typings or exported in the typing files\nexport function observer<P extends object, TRef = {}>(\n    baseComponent: React.RefForwardingComponent<TRef, P>,\n    options?: IObserverOptions\n) {\n    // The working of observer is explained step by step in this talk: https://www.youtube.com/watch?v=cPF4iBedoF0&feature=youtu.be&t=1307\n    if (isUsingStaticRendering()) {\n        return baseComponent\n    }\n\n    const realOptions = {\n        forwardRef: false,\n        ...options\n    }\n\n    const baseComponentName = baseComponent.displayName || baseComponent.name\n\n    const wrappedComponent = (props: P, ref: React.Ref<TRef>) => {\n        return useObserver(() => baseComponent(props, ref), baseComponentName)\n    }\n    wrappedComponent.displayName = baseComponentName\n\n    // memo; we are not intested in deep updates\n    // in props; we assume that if deep objects are changed,\n    // this is in observables, which would have been tracked anyway\n    let memoComponent\n    if (realOptions.forwardRef) {\n        // we have to use forwardRef here because:\n        // 1. it cannot go before memo, only after it\n        // 2. forwardRef converts the function into an actual component, so we can't let the baseComponent do it\n        //    since it wouldn't be a callable function anymore\n        memoComponent = memo(forwardRef(wrappedComponent))\n    } else {\n        memoComponent = memo(wrappedComponent)\n    }\n\n    copyStaticProperties(baseComponent, memoComponent)\n    memoComponent.displayName = baseComponentName\n\n    return memoComponent\n}\n\n// based on https://github.com/mridgway/hoist-non-react-statics/blob/master/src/index.js\nconst hoistBlackList: any = {\n    $$typeof: true,\n    render: true,\n    compare: true,\n    type: true\n}\n\nfunction copyStaticProperties(base: any, target: any) {\n    Object.keys(base).forEach(key => {\n        if (!hoistBlackList[key]) {\n            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(base, key)!)\n        }\n    })\n}\n","import { useObserver } from \"./useObserver\"\n\ninterface IObserverProps {\n    children?(): React.ReactElement<any>\n    render?(): React.ReactElement<any>\n}\n\nfunction ObserverComponent({ children, render }: IObserverProps) {\n    const component = children || render\n    if (typeof component !== \"function\") {\n        return null\n    }\n    return useObserver(component)\n}\nObserverComponent.propTypes = {\n    children: ObserverPropsCheck,\n    render: ObserverPropsCheck\n}\nObserverComponent.displayName = \"Observer\"\n\nexport { ObserverComponent as Observer }\n\nfunction ObserverPropsCheck(\n    props: { [k: string]: any },\n    key: string,\n    componentName: string,\n    location: any,\n    propFullName: string\n) {\n    const extraKey = key === \"children\" ? \"render\" : \"children\"\n    const hasProp = typeof props[key] === \"function\"\n    const hasExtraProp = typeof props[extraKey] === \"function\"\n    if (hasProp && hasExtraProp) {\n        return new Error(\n            \"MobX Observer: Do not use children and render in the same time in`\" + componentName\n        )\n    }\n\n    if (hasProp || hasExtraProp) {\n        return null\n    }\n    return new Error(\n        \"Invalid prop `\" +\n            propFullName +\n            \"` of type `\" +\n            typeof props[key] +\n            \"` supplied to\" +\n            \" `\" +\n            componentName +\n            \"`, expected `function`.\"\n    )\n}\n","import { observable, runInAction } from \"mobx\"\nimport React from \"react\"\n\nimport { isPlainObject } from \"./utils\"\n\nexport function useAsObservableSourceInternal<TSource>(\n    current: TSource,\n    usedByLocalStore: boolean\n): TSource {\n    const culprit = usedByLocalStore ? \"useLocalStore\" : \"useAsObservableSource\"\n    if (usedByLocalStore && current === undefined) {\n        return undefined as any\n    }\n    if (process.env.NODE_ENV !== \"production\" && !isPlainObject(current)) {\n        throw new Error(\n            `${culprit} expects a plain object as ${usedByLocalStore ? \"second\" : \"first\"} argument`\n        )\n    }\n\n    const [res] = React.useState(() => observable(current, {}, { deep: false }))\n    if (\n        process.env.NODE_ENV !== \"production\" &&\n        Object.keys(res).length !== Object.keys(current).length\n    ) {\n        throw new Error(`the shape of objects passed to ${culprit} should be stable`)\n    }\n    runInAction(() => {\n        Object.assign(res, current)\n    })\n    return res\n}\n\nexport function useAsObservableSource<TSource>(current: TSource): TSource {\n    return useAsObservableSourceInternal(current, false)\n}\n","import { observable, runInAction, transaction } from \"mobx\"\nimport React from \"react\"\n\nimport { useAsObservableSourceInternal } from \"./useAsObservableSource\"\nimport { isPlainObject } from \"./utils\"\n\nexport function useLocalStore<TStore extends Record<string, any>, TSource extends object = any>(\n    initializer: (source: TSource) => TStore,\n    current?: TSource\n): TStore {\n    const source = useAsObservableSourceInternal<TSource | undefined>(current, true)\n\n    return React.useState(() => {\n        const local = observable(initializer(source as TSource))\n        if (isPlainObject(local)) {\n            runInAction(() => {\n                Object.keys(local).forEach(key => {\n                    const value = local[key]\n                    if (typeof value === \"function\") {\n                        // @ts-ignore No idea why ts2536 is popping out here\n                        local[key] = wrapInTransaction(value, local)\n                    }\n                })\n            })\n        }\n        return local\n    })[0]\n}\n\n// tslint:disable-next-line: ban-types\nfunction wrapInTransaction(fn: Function, context: object) {\n    return (...args: unknown[]) => {\n        return transaction(() => fn.apply(context, args))\n    }\n}\n"]},"metadata":{},"sourceType":"module"}